














//AUTOGENERATED, DO NOTMODIFY.
//Do not edit this file directly.

#pragma warning disable 1591 // Missing XML comment for publicly visible type or member
// ReSharper disable CheckNamespace

using System;
using RethinkDb.Driver.Ast;
using RethinkDb.Driver.Model;
using RethinkDb.Driver.Proto;
using System.Collections;
using System.Collections.Generic;

    using System.Threading;


namespace RethinkDb.Driver.Ast {

    public partial class Func : ReqlExpr {

    
    // CHECK PARTIAL CLASS FOR MEMBERVARS

    
    
    
        protected Func(Arguments args) : base(TermType.FUNC, args, null)
        {
        }



    
    
    
    public static Func FromLambda(Delegate function){
    
        var func0 = function as ReqlFunction0;
        if( func0 != null )
        {
            return new Func(Arguments.Make(new List<object>(),
                Util.ToReqlAst( func0() )));
        }
            //Function 1
            var func1 = function as ReqlFunction1;
            if( func1 != null){
                int var1 = NextVarId();
                var varIds = new List<int>{ 
                    var1,
                };
                var appliedFunction = func1(
                    new Var(var1) 
                );
                return new Func(Arguments.Make(
                        new MakeArray(varIds),
                        Util.ToReqlAst(appliedFunction)
                ));
            }
            //Function 2
            var func2 = function as ReqlFunction2;
            if( func2 != null){
                int var1 = NextVarId();
                int var2 = NextVarId();
                var varIds = new List<int>{ 
                    var1,
                    var2,
                };
                var appliedFunction = func2(
                    new Var(var1) ,
                    new Var(var2) 
                );
                return new Func(Arguments.Make(
                        new MakeArray(varIds),
                        Util.ToReqlAst(appliedFunction)
                ));
            }
            //Function 3
            var func3 = function as ReqlFunction3;
            if( func3 != null){
                int var1 = NextVarId();
                int var2 = NextVarId();
                int var3 = NextVarId();
                var varIds = new List<int>{ 
                    var1,
                    var2,
                    var3,
                };
                var appliedFunction = func3(
                    new Var(var1) ,
                    new Var(var2) ,
                    new Var(var3) 
                );
                return new Func(Arguments.Make(
                        new MakeArray(varIds),
                        Util.ToReqlAst(appliedFunction)
                ));
            }
            //Function 4
            var func4 = function as ReqlFunction4;
            if( func4 != null){
                int var1 = NextVarId();
                int var2 = NextVarId();
                int var3 = NextVarId();
                int var4 = NextVarId();
                var varIds = new List<int>{ 
                    var1,
                    var2,
                    var3,
                    var4,
                };
                var appliedFunction = func4(
                    new Var(var1) ,
                    new Var(var2) ,
                    new Var(var3) ,
                    new Var(var4) 
                );
                return new Func(Arguments.Make(
                        new MakeArray(varIds),
                        Util.ToReqlAst(appliedFunction)
                ));
            }
    
        throw new ReqlDriverError("Arity of ReqlLambda not recognized!");
    }

    


    


    

    
        /// <summary>
        /// Get a single field from an object. If called on a sequence, gets that field from every object in the sequence, skipping objects that lack it.
        /// </summary>
        /// <param name="bracket"></param>
        public new Bracket this[string bracket] => base[bracket];
        
        /// <summary>
        /// Get the nth element of a sequence, counting from zero. If the argument is negative, count from the last element.
        /// </summary>
        /// <param name="bracket"></param>
        /// <returns></returns>
        public new Bracket this[int bracket] => base[bracket];


    















       
      

    
    // CHECK PARTIAL CLASS FOR SPECIAL METHODS



    
    }
}
